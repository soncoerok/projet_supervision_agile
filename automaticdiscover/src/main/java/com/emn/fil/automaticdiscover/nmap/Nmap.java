package com.emn.fil.automaticdiscover.nmap;

import java.io.File;
import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.springframework.beans.factory.annotation.Autowired;
import com.emn.fil.automaticdiscover.Main;
import com.emn.fil.automaticdiscover.dto.IP;
import com.emn.fil.automaticdiscover.dto.IPMask;
import com.emn.fil.automaticdiscover.dto.Scan;
import com.emn.fil.automaticdiscover.ihm.Frame;
import com.emn.fil.automaticdiscover.ihm.ShowDialog;
import com.emn.fil.automaticdiscover.parser.BaliseXML;
import com.emn.fil.automaticdiscover.parser.SaxHandler;
import com.emn.fil.automaticdiscover.utils.Commande;
import com.emn.fil.automaticdiscover.utils.ExecutionProgramme;

/**
 * Classe qui permet d'utiliser la commande Nmap.
 * 
 * @author Clement
 * 
 */
public class Nmap /*implements Runnable*/ {
	/** Constante pour ajuster la vitesse du scan. */
	private static final String LENT = "Lent";
	/** Constante pour ajuster la vitesse du scan. */
	private static final String MOYEN = "Moyen";
	/** Constante pour ajuster la vitesse du scan. */
	private static final String RAPIDE = "Rapide";

	/** Chemin où on enregistre le fichier xml. */
	private static String CHEMIN_ENREGISTREMENT_FICHIER = "./resultat.xml";

	@Autowired
	private Scan scan;

	private IPMask ipMask;

	private Frame frame;

	private boolean scanTermine;

	private Commande commandeNmap;

	public Nmap() {}

	public Nmap(Frame frame) throws UnknownHostException {
		this.frame = frame;
		this.scanTermine = false;
	}

	/**
	 * Méthode permettant de scanner le réseau indiqué.
	 * 
	 * @param ipMask
	 *            est l'ip voulue
	 * @throws IOException
	 */
	private Scan scanner(IPMask ipMask) throws IOException {
		/* Build of the commande. */
		commandeNmap = new Commande(frame.getCheminNmap());

		// Process to do
		commandeNmap.ajouterOption(OptionsNmap.HOST_NAME_DETECTION.getOption());
		commandeNmap.ajouterOption(OptionsNmap.OS_DETECTION.getOption());

		// Timing and performing
		
		// Vitess and performing chosse by user
		if (frame.getVistesseScan().equals(Nmap.LENT)){
			this.modifierVitesseScan(700, 100, 0);
		}
		
		else if (frame.getVistesseScan().equals(Nmap.MOYEN)){
			this.modifierVitesseScan(200, 15, 0);
		}
		
		else if (frame.getVistesseScan().equals(Nmap.RAPIDE)){
			commandeNmap.ajouterOption(OptionsNmap.FASTER.getOption());
			this.modifierVitesseScan(100, 10, 0);
		}
		
		//commandeNmap.ajouterOption(OptionsNmap.TEMPS_ABANDON_MACHINE.getOption());
		commandeNmap.ajouterOptionAvecArguments(OptionsNmap.EXCLUSION_IP.getOption(), new String[] { InetAddress.getLocalHost().getHostAddress() });

		// Output
		commandeNmap.ajouterOptionAvecArguments(OptionsNmap.EXPORT_XML.getOption(), new String[] { CHEMIN_ENREGISTREMENT_FICHIER });

		commandeNmap.ajouterOption(ipMask.toString());
		System.out.println(commandeNmap.getCommandeFinale());

		// Exec
		ExecutionProgramme.exec(commandeNmap.getCommandeFinale());

		// Parsing of the xml generated by nmap.
		return parsageResultat();
	}

	/**
	 * Méthode qui permet de modifier le type de scan Lent, Moyen ou Rapide (a configurer avec l'appli)
	 * 
	 * @param tempsMaxabandonPaquet
	 * @param tempsInitialAbandonPaquet
	 * @param nombreEssaiSansReponses
	 */
	public void modifierVitesseScan(int tempsMaxabandonPaquet, int tempsInitialAbandonPaquet, int nombreEssaiSansReponses) {
		commandeNmap.ajouterOptionAvecArguments(OptionsNmap.TEMPS_MAX_ABANDON_PAQUET.getOption(),
				new String[] { String.valueOf(tempsMaxabandonPaquet) + "ms" });
		commandeNmap.ajouterOptionAvecArguments(OptionsNmap.TEMPS_INITIAL_ABANDON_PAQUET.getOption(),
				new String[] { String.valueOf(tempsInitialAbandonPaquet) + "ms" });
		commandeNmap.ajouterOptionAvecArguments(OptionsNmap.NOMBRE_ESSAI_SANS_REPONSES.getOption(),
				new String[] { String.valueOf(nombreEssaiSansReponses) });
	}

	public static Scan parsageResultat() {
		try {
			// definition des attributs a recup
			List<BaliseXML> listeBalise = new ArrayList<BaliseXML>();
			listeBalise.add(new BaliseXML("nmaprun", Arrays.asList("startstr")));
			listeBalise.add(new BaliseXML("address", Arrays.asList("addr", "addrtype", "vendor")));
			listeBalise.add(new BaliseXML("hostname", Arrays.asList("name")));
			listeBalise.add(new BaliseXML("osclass", Arrays.asList("osfamily")));

			SAXParserFactory usine = SAXParserFactory.newInstance();
			SAXParser parseur = usine.newSAXParser();

			File fichier = new File(CHEMIN_ENREGISTREMENT_FICHIER);
			SaxHandler gestionnaire = new SaxHandler();
			gestionnaire.setListeBalise(listeBalise);
			parseur.parse(fichier, gestionnaire);

			return gestionnaire.getScan();
		} catch (Exception e) {
			Main.log.trace(e.getStackTrace());
			ShowDialog dialog = new ShowDialog("Problème lors de la récupération des machines !\n" + e.getMessage());
			dialog.setVisible(true);
		}
		return null;
	}

	/**
	 * Methode qui permet de lancer le scan.
	 * 
	 * @throws IOException
	 */
	public void lancer() throws IOException {
		this.scanTermine = false;
		
		String ipReseau = InetAddress.getLocalHost().getHostAddress();
		int masque = frame.getMasqueReseau();
		if(this.frame.isIpChecked()) {
			ipReseau = frame.getTextFieldIp();
			masque = frame.getMasqueIp();
		}
		
		this.ipMask = new IPMask(new IP(ipReseau), masque);
		this.scan = scanner(ipMask);
		this.scanTermine = true;
	}

	public Scan getScan() {
		return scan;
	}

	public boolean isScanTermine() {
		return scanTermine;
	}

	/*public void run() {
		try {
			this.lancer();
		} catch (IOException e) {
			JOptionPane.showMessageDialog(frame, "Problème lors du lancement de l'analyse du réseau !\n" + e.getMessage(), "Nmap erreur",
					JOptionPane.ERROR_MESSAGE);
		}
	}*/
}